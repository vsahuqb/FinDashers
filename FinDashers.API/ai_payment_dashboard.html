<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>AI Payment Analytics Dashboard</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
    }
    .header {
        text-align: center;
        color: white;
        margin-bottom: 30px;
    }
    .header h1 {
        font-size: 2.5rem;
        font-weight: 300;
        margin-bottom: 10px;
    }
    .ai-controls {
        background: rgba(255,255,255,0.1);
        backdrop-filter: blur(10px);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 30px;
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 15px;
        align-items: center;
    }
    .control-group {
        text-align: center;
    }
    .control-group label {
        color: white;
        display: block;
        margin-bottom: 5px;
        font-size: 0.9rem;
    }
    input, select, button {
        padding: 8px 15px;
        border: none;
        border-radius: 20px;
        font-size: 14px;
        width: 100%;
    }
    button {
        background: #4facfe;
        color: white;
        cursor: pointer;
        font-weight: bold;
    }
    button:hover {
        background: #00f2fe;
    }
    .ai-insights {
        background: rgba(255,255,255,0.1);
        backdrop-filter: blur(10px);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 30px;
        color: white;
    }
    .insight-item {
        background: rgba(255,255,255,0.1);
        padding: 10px;
        border-radius: 10px;
        margin-bottom: 10px;
    }
    .status-indicator {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 10px;
    }
    .status-live { background: #4CAF50; }
    .status-warning { background: #FF9800; }
    .status-error { background: #F44336; }
    .section {
        margin-bottom: 40px;
    }
    .section h2 {
        color: white;
        font-size: 1.8rem;
        margin-bottom: 20px;
        text-align: center;
    }
    .container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 40px;
        margin-bottom: 40px;
    }
    .chart {
        background: #fff;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0px 1px 4px rgba(0,0,0,0.1);
        min-height: 300px;
    }
    .kpi-card {
        background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        color: white;
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0px 1px 4px rgba(0,0,0,0.1);
        margin-bottom: 40px;
    }
    .kpi-main {
        text-align: center;
        margin-bottom: 20px;
    }
    .kpi-main h2 {
        font-size: 3rem;
        margin-bottom: 5px;
    }
    .kpi-main p {
        font-size: 1.2rem;
        opacity: 0.9;
    }
    .kpi-metrics {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 15px;
    }
    .kpi-metric {
        text-align: center;
        background: rgba(255,255,255,0.2);
        padding: 15px;
        border-radius: 10px;
    }
    .kpi-value {
        font-size: 1.5rem;
        font-weight: bold;
    }
    .kpi-label {
        font-size: 0.9rem;
        opacity: 0.9;
    }
</style>
</head>
<body>

<div class="header">
    <h1>AI Payment Analytics Dashboard</h1>
    <p>Real-time Intelligent Payment Monitoring</p>
</div>

<div class="ai-controls">
    <div class="control-group">
        <label>Data Source</label>
        <select id="dataSource">
            <option value="file">Upload File</option>
            <option value="api">API Endpoint</option>
            <option value="websocket">WebSocket Stream</option>
        </select>
    </div>
    <div class="control-group">
        <label>Refresh Interval</label>
        <select id="refreshInterval">
            <option value="5000">5 seconds</option>
            <option value="30000">30 seconds</option>
            <option value="60000">1 minute</option>
            <option value="300000">5 minutes</option>
        </select>
    </div>
    <div class="control-group">
        <label>AI Agent</label>
        <button id="toggleAgent">Start AI Agent</button>
    </div>
</div>

<div style="text-align: center; margin-bottom: 20px;">
    <input type="file" id="fileInput" accept=".json" style="padding: 12px 20px; border-radius: 25px; border: none; font-size: 14px; cursor: pointer;">
    <input type="text" id="apiUrl" placeholder="Enter API URL" style="display: none; padding: 12px 20px; border-radius: 25px; border: none; font-size: 14px; width: 400px; margin-top: 10px;">
</div>

<div class="ai-insights" id="aiInsights">
    <h3>AI Insights</h3>
    <div id="insightsList">
        <div class="insight-item">
            <span class="status-indicator status-live"></span>
            AI Agent Ready - Upload data or configure data source to begin analysis
        </div>
    </div>
</div>

<div class="section">
    <div id="kpiCard" class="kpi-card"></div>
</div>

<div class="section">
    <h2>Transaction Flow Analysis</h2>
    <div class="container">
        <div id="funnelChart" class="chart"></div>
        <div id="successTrend" class="chart"></div>
    </div>
</div>

<div class="section">
    <h2>Performance Breakdown</h2>
    <div class="container">
        <div id="paymentMethodChart" class="chart"></div>
        <div id="locationHeatmap" class="chart"></div>
    </div>
</div>

<script>
class AIPaymentAgent {
    constructor() {
        this.isActive = false;
        this.dataHistory = [];
        this.refreshTimer = null;
        this.currentData = [];
        this.insights = [];
        this.thresholds = {
            successRate: 95,
            avgResponseTime: 2000,
            failureSpike: 10
        };
        this.initializeControls();
    }

    initializeControls() {
        document.getElementById('dataSource').addEventListener('change', (e) => {
            this.handleDataSourceChange(e.target.value);
        });

        document.getElementById('toggleAgent').addEventListener('click', () => {
            this.toggleAgent();
        });

        document.getElementById('fileInput').addEventListener('change', (e) => {
            this.handleFileUpload(e);
        });

        document.getElementById('refreshInterval').addEventListener('change', (e) => {
            this.updateRefreshInterval(parseInt(e.target.value));
        });
    }

    handleDataSourceChange(source) {
        const fileInput = document.getElementById('fileInput');
        const apiUrl = document.getElementById('apiUrl');
        
        if (source === 'file') {
            fileInput.style.display = 'inline-block';
            apiUrl.style.display = 'none';
        } else if (source === 'api') {
            fileInput.style.display = 'none';
            apiUrl.style.display = 'inline-block';
        } else {
            fileInput.style.display = 'none';
            apiUrl.style.display = 'none';
        }
    }

    toggleAgent() {
        const button = document.getElementById('toggleAgent');
        if (this.isActive) {
            this.stopAgent();
            button.textContent = 'Start AI Agent';
            button.style.background = '#4facfe';
        } else {
            this.startAgent();
            button.textContent = 'Stop AI Agent';
            button.style.background = '#ff6b6b';
        }
    }

    startAgent() {
        this.isActive = true;
        this.addInsight('AI Agent Started - Monitoring payment data in real-time', 'live');
        
        const interval = parseInt(document.getElementById('refreshInterval').value);
        
        // Initial fetch
        this.fetchAndAnalyzeData();
        
        // Set up periodic refresh
        this.refreshTimer = setInterval(() => {
            this.fetchAndAnalyzeData();
        }, interval);
    }

    stopAgent() {
        this.isActive = false;
        if (this.refreshTimer) {
            clearInterval(this.refreshTimer);
            this.refreshTimer = null;
        }
        this.addInsight('AI Agent Stopped', 'warning');
    }

    async fetchAndAnalyzeData() {
        const source = document.getElementById('dataSource').value;
        
        try {
            let newData = [];
            
            if (source === 'api') {
                const apiUrl = document.getElementById('apiUrl').value;
                if (apiUrl) {
                    const response = await fetch(apiUrl);
                    newData = await response.json();
                    if (!Array.isArray(newData)) newData = [newData];
                    this.addInsight(`üì° Fetched ${newData.length} transactions from API`, 'live');
                }
            } else if (source === 'websocket') {
                // Simulate real-time data
                newData = this.generateSimulatedData();
                this.addInsight(`üîÑ Generated ${newData.length} simulated transactions`, 'live');
            } else if (source === 'file' && this.currentData.length > 0) {
                // For file mode, just re-analyze existing data
                this.analyzeData();
                return;
            }

            if (newData.length > 0) {
                this.processNewData(newData);
            }
        } catch (error) {
            this.addInsight(`‚ùå Data fetch error: ${error.message}`, 'error');
        }
    }

    generateSimulatedData() {
        // Simulate new payment transactions
        const count = Math.floor(Math.random() * 10) + 1;
        const newTransactions = [];
        
        for (let i = 0; i < count; i++) {
            newTransactions.push({
                id: Date.now() + i,
                success: Math.random() > 0.1,
                event_date: new Date().toISOString(),
                payment_method: ['visa', 'mastercard', 'applepay', 'googlepay'][Math.floor(Math.random() * 4)],
                approved_amount: Math.floor(Math.random() * 100) + 10,
                location_id: `LOC_${Math.floor(Math.random() * 5) + 1}`,
                event_code: ['AUTHORISATION', 'CAPTURE', 'REFUND'][Math.floor(Math.random() * 3)]
            });
        }
        
        return newTransactions;
    }

    processNewData(newData) {
        // Merge with existing data
        this.currentData = [...this.currentData, ...newData];
        
        // Keep only last 1000 transactions for performance
        if (this.currentData.length > 1000) {
            this.currentData = this.currentData.slice(-1000);
        }

        // Analyze and update dashboard
        this.analyzeData();
        this.updateDashboard();
        
        this.addInsight(`‚úÖ Dashboard updated with ${this.currentData.length} total transactions`, 'live');
    }

    analyzeData() {
        if (this.currentData.length === 0) return;

        const recentData = this.currentData.slice(-100); // Last 100 transactions
        const successRate = (recentData.filter(d => d.success).length / recentData.length) * 100;
        
        // AI Analysis
        if (successRate < this.thresholds.successRate) {
            this.addInsight(`‚ö†Ô∏è Success rate dropped to ${successRate.toFixed(1)}% - Below threshold of ${this.thresholds.successRate}%`, 'warning');
        }

        // Detect payment method issues
        const methodStats = {};
        recentData.forEach(d => {
            const method = d.payment_method || 'unknown';
            if (!methodStats[method]) methodStats[method] = { success: 0, total: 0 };
            methodStats[method].total++;
            if (d.success) methodStats[method].success++;
        });

        Object.keys(methodStats).forEach(method => {
            const stats = methodStats[method];
            const rate = (stats.success / stats.total) * 100;
            if (rate < 90 && stats.total > 5) {
                this.addInsight(`üîç ${method} payment method showing ${rate.toFixed(1)}% success rate`, 'warning');
            }
        });

        // Detect location issues
        const locationStats = {};
        recentData.forEach(d => {
            const location = d.location_id || 'unknown';
            if (!locationStats[location]) locationStats[location] = { success: 0, total: 0 };
            locationStats[location].total++;
            if (d.success) locationStats[location].success++;
        });

        Object.keys(locationStats).forEach(location => {
            const stats = locationStats[location];
            const rate = (stats.success / stats.total) * 100;
            if (rate < 85 && stats.total > 3) {
                this.addInsight(`üìç Location ${location} experiencing issues: ${rate.toFixed(1)}% success rate`, 'error');
            }
        });
    }

    addInsight(message, type = 'live') {
        const timestamp = new Date().toLocaleTimeString();
        this.insights.unshift({ message, type, timestamp });
        
        // Keep only last 10 insights
        if (this.insights.length > 10) {
            this.insights = this.insights.slice(0, 10);
        }

        this.updateInsightsDisplay();
    }

    updateInsightsDisplay() {
        const container = document.getElementById('insightsList');
        container.innerHTML = this.insights.map(insight => `
            <div class="insight-item">
                <span class="status-indicator status-${insight.type}"></span>
                [${insight.timestamp}] ${insight.message}
            </div>
        `).join('');
    }

    handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                let data = JSON.parse(e.target.result);
                if (!Array.isArray(data)) data = [data];
                
                this.currentData = data;
                this.addInsight(`üìÅ Loaded ${data.length} transactions from file`, 'live');
                this.analyzeData();
                this.updateDashboard();
            } catch (err) {
                this.addInsight(`‚ùå Invalid JSON file: ${err.message}`, 'error');
            }
        };
        reader.readAsText(file);
    }

    updateRefreshInterval(interval) {
        if (this.isActive && this.refreshTimer) {
            clearInterval(this.refreshTimer);
            this.refreshTimer = setInterval(() => {
                this.fetchAndAnalyzeData();
            }, interval);
            this.addInsight(`üîÑ Refresh interval updated to ${interval/1000} seconds`, 'live');
        }
    }

    updateDashboard() {
        if (this.currentData.length === 0) return;
        
        processPaymentData(this.currentData);
    }
}

// Initialize AI Agent
const aiAgent = new AIPaymentAgent();

// Original dashboard functions (simplified)
function processPaymentData(data) {
    data.forEach(d => {
        if (typeof d.success === 'string') {
            d.success = d.success.toLowerCase() === 'true';
        }
        if (d.event_date) {
            try {
                d._event_ts = new Date(d.event_date);
            } catch (_) {
                d._event_ts = new Date(d.created_at || Date.now());
            }
        } else {
            d._event_ts = new Date(d.created_at || Date.now());
        }
    });

    const approved = data.filter(d => d.success === true);
    const declined = data.filter(d => d.success === false);
    const successRate = ((approved.length / data.length) * 100).toFixed(1);
    const netSales = approved.reduce((sum, t) => sum + (t.approved_amount || t.amount?.value || 0), 0);
    const avgTicket = approved.length > 0 ? (netSales / approved.length).toFixed(2) : 0;

    generateKPICard(successRate, approved.length, declined.length, netSales, avgTicket);
    generateFunnelChart(data);
    generateSuccessTrend(data);
    generatePaymentMethodChart(data);
    generateLocationHeatmap(data);
}

function generateKPICard(successRate, approvedCount, declinedCount, netSales, avgTicket) {
    document.getElementById("kpiCard").innerHTML = `
        <div class="kpi-main">
            <h2>${successRate}%</h2>
            <p>Payment Success Rate</p>
        </div>
        <div class="kpi-metrics">
            <div class="kpi-metric">
                <div class="kpi-value">${approvedCount.toLocaleString()}</div>
                <div class="kpi-label">Approved</div>
            </div>
            <div class="kpi-metric">
                <div class="kpi-value">${declinedCount.toLocaleString()}</div>
                <div class="kpi-label">Declined</div>
            </div>
            <div class="kpi-metric">
                <div class="kpi-value">$${netSales.toLocaleString()}</div>
                <div class="kpi-label">Net Sales</div>
            </div>
            <div class="kpi-metric">
                <div class="kpi-value">$${avgTicket}</div>
                <div class="kpi-label">Avg Ticket</div>
            </div>
        </div>
    `;
}

function generateFunnelChart(data) {
    const initiated = data.length;
    const authorized = data.filter(d => d.event_code === "AUTHORISATION" || d.success === true).length;
    const captured = data.filter(d => d.event_code === "CAPTURE" || d.success === true).length;
    const settled = data.filter(d => d.settlement_status === "success" || d.settlement_date).length;
    const refunded = data.filter(d => d.event_code === "REFUND").length;

    Plotly.newPlot("funnelChart", [{
        type: "funnel",
        y: ["Initiated", "Authorized", "Captured", "Settled", "Refunded"],
        x: [initiated, authorized, captured, settled || captured, refunded],
        marker: { color: ["#4facfe", "#00f2fe", "#96ceb4", "#feca57", "#ff6b6b"] }
    }], { title: "Transaction Funnel", margin: { t: 40, l: 80, r: 20, b: 40 } });
}

function generateSuccessTrend(data) {
    const hourlySuccess = {};
    data.forEach(d => {
        const hour = d._event_ts.getHours();
        if (!hourlySuccess[hour]) hourlySuccess[hour] = { success: 0, total: 0 };
        hourlySuccess[hour].total++;
        if (d.success) hourlySuccess[hour].success++;
    });

    const hours = Array.from({length: 24}, (_, i) => i);
    const rates = hours.map(h => {
        const stats = hourlySuccess[h];
        return stats ? ((stats.success / stats.total) * 100).toFixed(1) : 0;
    });

    Plotly.newPlot("successTrend", [{
        x: hours, y: rates, type: "scatter", mode: "lines+markers",
        line: { color: "#4facfe", width: 3 }, marker: { size: 6, color: "#00f2fe" }
    }], {
        title: "Hourly Success Rate",
        xaxis: { title: "Hour of Day" },
        yaxis: { title: "Success Rate (%)", range: [0, 100] },
        margin: { t: 40, l: 60, r: 20, b: 40 }
    });
}

function generatePaymentMethodChart(data) {
    const methodStats = {};
    data.forEach(d => {
        const method = d.payment_method || "Unknown";
        if (!methodStats[method]) methodStats[method] = { success: 0, failure: 0 };
        if (d.success) methodStats[method].success++;
        else methodStats[method].failure++;
    });

    const methods = Object.keys(methodStats);
    const successCounts = methods.map(m => methodStats[m].success);
    const failureCounts = methods.map(m => methodStats[m].failure);

    Plotly.newPlot("paymentMethodChart", [{
        x: methods, y: successCounts, name: "Success", type: "bar", marker: { color: "#96ceb4" }
    }, {
        x: methods, y: failureCounts, name: "Failure", type: "bar", marker: { color: "#ff6b6b" }
    }], {
        title: "Payment Method Performance",
        xaxis: { title: "Payment Method" },
        yaxis: { title: "Count" },
        barmode: "stack",
        margin: { t: 40, l: 60, r: 20, b: 60 }
    });
}

function generateLocationHeatmap(data) {
    const locationStats = {};
    data.forEach(d => {
        const location = d.location_id || d.terminal_id || "Unknown";
        if (!locationStats[location]) locationStats[location] = { success: 0, total: 0 };
        locationStats[location].total++;
        if (d.success) locationStats[location].success++;
    });

    const locations = Object.keys(locationStats);
    const failureRates = locations.map(loc => {
        const stats = locationStats[loc];
        return ((1 - stats.success / stats.total) * 100).toFixed(1);
    });

    Plotly.newPlot("locationHeatmap", [{
        z: [failureRates], x: locations, y: ["Failure Rate"], type: "heatmap",
        colorscale: [[0, "#96ceb4"], [0.5, "#feca57"], [1, "#ff6b6b"]],
        hovertemplate: "Location: %{x}<br>Failure Rate: %{z}%<extra></extra>"
    }], {
        title: "Location Failure Rates",
        xaxis: { title: "Location/Terminal ID" },
        yaxis: { showticklabels: false },
        margin: { t: 40, l: 60, r: 20, b: 80 }
    });
}

</script>
</body>
</html>